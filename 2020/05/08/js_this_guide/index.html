<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="生活随笔、前端乱炖、情感沟通、职业交流、旅行笔记">
    <meta name="keyword"  content="undefined">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        this指向知多少 - 灵感之见
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css" type="text/css">
    <link rel="stylesheet" href="/css/gitment.css" type="text/css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/idea.png" />
        </div>
        <div class="name">
            <i>灵感_idea</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#this等于自己？"><span class="toc-text">this等于自己？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指向自身"><span class="toc-text">指向自身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指向所在作用域"><span class="toc-text">指向所在作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this是什么"><span class="toc-text">this是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#绑定规则"><span class="toc-text">绑定规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#默认绑定"><span class="toc-text">默认绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式绑定"><span class="toc-text">隐式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式丢失"><span class="toc-text">隐式丢失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#显式绑定"><span class="toc-text">显式绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、call-apply"><span class="toc-text">一、call/apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、bind"><span class="toc-text">二、bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、API调用上下文"><span class="toc-text">三、API调用上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new绑定"><span class="toc-text">new绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#规则优先级"><span class="toc-text">规则优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="site-slogan-mobile">
            <i> 学习让人快乐，而分享加倍 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        this指向知多少
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-05-08</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#JavaScript，学习" title="JavaScript，学习">JavaScript，学习</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <p>”this“在JavaScript中很常见，用起来也很”香“，每当我们想访问一个值或者设置一个值，常会用到它，原生和框架都是，但它同时又让人困惑，使我们写的代码达不到预期效果，甚至引起bug，本文我们就来看看，this的指向遵循哪些规律。</p>
<h2 id="this等于自己？"><a href="#this等于自己？" class="headerlink" title="this等于自己？"></a>this等于自己？</h2><p>先看几个看似正常却错误的理解。</p>
<h3 id="指向自身"><a href="#指向自身" class="headerlink" title="指向自身"></a>指向自身</h3><p>比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//记录add被调用的次数</span></span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"计数"</span> + num)</span><br><span class="line">&#125;</span><br><span class="line">add.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(add.count) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>可以看到，结果跟预期的不一样，count未发生改变。</p>
<p>实际上，这段代码无意间创建了一个全局变量 count，在执行add的时候，并未改动add的count。</p>
<h3 id="指向所在作用域"><a href="#指向所在作用域" class="headerlink" title="指向所在作用域"></a>指向所在作用域</h3><p>还是先看代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">this</span>.two();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">one();  <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>
<p>这种情况略特殊，因为并不总是错的，这里one调用two能够成功，但却无法因此利用two里面的this来访问one里面的a，这是做不到的。</p>
<p>看了两个错误用法，怎样是对的呢？接着往下看。</p>
<h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><p>this指代变量或者方法和对象之间的从属关系，但它是在运行时进行绑定，而不是编写时，这取决于函数调用时的多种条件，所以，<strong>this的绑定和函数声明的位置无关，取决于函数调用的方式</strong>。</p>
<p>上面这句话不难理解，因为在哪调用函数似乎显而易见，其实不然，在某些编程模式下，调用位置可能被隐藏，这时我们就要顺着调用的路径找到调用位置，然后判断它符合哪种绑定规则。</p>
<h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">get();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这种属于独立的函数调用，应用的是函数的默认绑定，this指向全局对象。</p>
<p>怎么判断默认绑定呢，因为它是使用不带任何修饰的函数引用进行调用的。但也要注意，只有在非严格模式下，this才绑定到全局，否则会提示undefined。</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>看调用位置是否被某个对象拥有或者包含。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span>,</span><br><span class="line">  get</span><br><span class="line">&#125;</span><br><span class="line">obj.get()  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这里我们把get函数放在了obj内，但严格来说，它仍不属于obj，只是被obj包含和调用，这个时候，this就指向了obj，this.a 就和 obj.a等价了。</p>
<p>只是这种情况需要注意的是，它有个就近的规则，就是它只属于离this最近的一层。像下面这段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a:<span class="number">3</span>,</span><br><span class="line">  get</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a:<span class="number">2</span>,</span><br><span class="line">  obj2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.obj2.get(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这段代码中，this绑定在了obj2上，而不是一直向上追溯。</p>
<h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><p>一个常见的问题就是被隐式绑定的函数丢失了绑定对象，导致应用默认绑定，this就到了全局或者undefined。</p>
<p>第一种情况：<strong>方法传递</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">3</span>,</span><br><span class="line">  get</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNum = obj.get;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"global"</span>;</span><br><span class="line"></span><br><span class="line">getNum(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>这里我们会发现，我们把obj的get方法给了getNum，却不是想象中的效果，其实我们上面就说了，这里的get并不真实属于obj，而只是在调用时，this被绑定到了obj，不信你可以像下面这么改一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"global"</span>;</span><br><span class="line"><span class="keyword">var</span> getNum = obj.get();</span><br><span class="line"><span class="built_in">console</span>.log(getNum)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>又是3，跟期望的一致，这就是细微差别导致结果的不同。</p>
<p>第二种情况：<strong>回调</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doGet</span>(<span class="params">get</span>)</span>&#123;</span><br><span class="line">  get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">3</span>,</span><br><span class="line">  get</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"global"</span>;</span><br><span class="line">doGet(obj.get);  <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>这种情况跟上面的类似，因为参数传递就是一种隐式赋值，这个时候，执行get方法的时候，还是全局的get，this绑定的就是全局对象了。</p>
<p>回调很常用，所以，因为回调函数而丢失this的情况也常见，甚至于，调用回调函数的函数可能会修改this，这就让代码行为更加地难以捕捉。</p>
<p>所以有什么好办法弥补这些不确定问题的发生么。</p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>通过上面的例子可以看到，要想把一个函数的this绑定到对象上，需要下面两个条件：</p>
<ul>
<li>函数作为对象的属性</li>
<li>通过属性间接调用函数</li>
</ul>
<p>如果不想这么做呢？</p>
<h3 id="一、call-apply"><a href="#一、call-apply" class="headerlink" title="一、call/apply"></a>一、call/apply</h3><p>JavaScript中的函数都有一些有用的特性，可以用来解决这个问题，比如：call 和 apply，因为可以直接指定this的绑定对象，所以称之为显式绑定。</p>
<p>可看如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">get.call(obj); <span class="comment">//  3</span></span><br></pre></td></tr></table></figure>
<p>通过get.call()，我们把this强制绑定到了obj上。</p>
<p>从绑定this的角度看，call和apply的区别只是参数的形式不同，call可以直接写参数，而apply需要以数组的形式传参。</p>
<p>遗憾的是，这仍无法解决上面提到的绑定丢失问题，但它的一种变通方法可以解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  get.call(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNum()  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里创建了一个函数给getNum，然后函数内部进行显式地绑定，这样以来，不论再怎样调用getNum，get的this都不会变了。</p>
<h3 id="二、bind"><a href="#二、bind" class="headerlink" title="二、bind"></a>二、bind</h3><p>因为上面提到的绑定方式较为常用，ES5直接提供了一个内置的方法——Function.prototype.bind。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNum = get.bind(obj);</span><br><span class="line"></span><br><span class="line">getNum()  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>bind()会返回一个硬编码的新函数，把指定的参数设置为this的上下文并调用原函数。</p>
<h3 id="三、API调用上下文"><a href="#三、API调用上下文" class="headerlink" title="三、API调用上下文"></a>三、API调用上下文</h3><p>有一些库，或者ES新版本的内置函数，会提供一个可选参数，它的作用和bind()类似，确保回调函数使用指定的this，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el,<span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  id:<span class="string">"item"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(get,obj);</span><br><span class="line"><span class="comment">// 1 "item"  2 "item"  3 "item"</span></span><br></pre></td></tr></table></figure>
<p>类似的这些函数实际就是通过call()或者apply()实现了显式绑定，这样可以少写一些代码。</p>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>我们很熟悉的一句话：”没有对象就new一个“。</p>
<p>JavaScript 中有一些内置对象函数和自定义函数的构造调用，都会用到new关键字，它会经历以下过程：</p>
<ul>
<li>创建一个新对象</li>
<li>新对象执行prototype连接</li>
<li>新对象绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，就返回这个对象</li>
</ul>
<p>就会有如下代码的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Get</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getNum = <span class="keyword">new</span> Get(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(getNum.a)  <span class="comment">//  2</span></span><br></pre></td></tr></table></figure>
<p>这是大家熟悉的用法，只是中间经历的过程不是表面那么简单，需要理解一下。</p>
<p>new是本文提到的最后一种可以影响this绑定的方法，下面看看这些规则的优先级。</p>
<h2 id="规则优先级"><a href="#规则优先级" class="headerlink" title="规则优先级"></a>规则优先级</h2><p>显然的，默认绑定优先级是最低的，它可以轻易被改变，所以，我们主要关心隐式绑定和显式绑定的优先级。可按照如下顺序进行判断：</p>
<ul>
<li><p>是否通过new调用来绑定，是，则绑定新创建的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getNum = <span class="keyword">new</span> Get();</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否直接或间接通过call、apply、bind绑定，是，绑定指定对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getNum = get.call(obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否在某个上下文对象中调用，是，则绑定那个上下文对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  getNum = obj.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果都不是，使用默认绑定。</p>
</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>曾有人问我，ES6当中比较喜欢哪个设计，我没多想，就说箭头函数，然后他问我，它跟之前的函数有什么不同，this绑定就是它们的不同之一。</p>
<p><strong>箭头函数不使用this的那几种规则，而是根据外层函数/全局作用域来决定</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a) =&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a:<span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a:<span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNum = get.call(obj1);</span><br><span class="line">getNum.call(obj2); <span class="comment">// 3,不是2</span></span><br></pre></td></tr></table></figure>
<p>因为get内部创建的箭头函数会捕获调用get时的this，getNum也会跟着一起绑定到obj1，且这种绑定无法被修改。</p>
<p>这种就像bind方法一样，确保函数被绑定到指定对象，它取代了传统的this机制。</p>
<p>实际上，在ES6之前，我们常用另外一种方法来实现它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;  <span class="comment">//  就是这里</span></span><br><span class="line">  <span class="built_in">console</span>.log(self.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">get.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>this绑定是个看似简单，又有一点复杂的东西，除了默认绑定和构造函数调用可以比较自然地理解，其他都绕了那么一点弯儿，但也不用怕，只要经过反复地思考和实践，掌握它们就是本能反应了。</p>
<p>本文尽量全面，仍难免疏漏，鉴于篇幅太长会增加学习负担，索性没有提及某些特殊情况，多数场景已经够用，欢迎交流探讨。</p>
<p>下篇见！~</p>

        
            <div class="donate-container">
    <div>
        <img src="/img/pencil.jpg" alt="" class="i-pencil">
    </div>
    <div class="site-slogan">
        <i> 学习让人快乐，而分享加倍 </i>
    </div>
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/wechat-pay.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js" type="text/javascript"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
